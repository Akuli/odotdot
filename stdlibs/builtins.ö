var Class = (get_class String);

# can't wait until the class builtin exists, bools are needed for creating that
var Bool = (new Class "Bool" Object);
var true = (new Bool);
var false = (new Bool);

# errors are defined as early as possible because rest of the code may throw them
var ArgError = (new Class "ArgError" Error);
var AssertError = (new Class "AssertError" Error);
var AttribError = (new Class "AttribError" Error);
var KeyError = (new Class "KeyError" Error);
var MathError = (new Class "MathError" Error);
var TypeError = (new Class "TypeError" Error);
var ValueError = (new Class "ValueError" Error);
var VariableError = (new Class "VariableError" Error);

{}.definition_scope.local_vars.delete "Class";


var add_method = (lambda "klass name lambda_with_this" {
    var getter = (lambda "this" {
        var result = (lambda_with_this.partial this);
        result.name = (name.concat " method");
        return result;
    });

    getter.name = ("getter of ".concat name);
    klass.getters.set name getter;
});

add_method Bool "setup" (lambda "this" {
    throw (new TypeError "cannot create new Bool objects, use true and false instead");
});

add_method Bool "to_debug_string" (lambda "this" {
    return ((new Mapping [[true "true"] [false "false"]]).get this);
});

add_method Mapping "get_with_fallback" (lambda "this key fallback" {
    catch {
        return (this.get key);
    } KeyError {
        return fallback;
    };
});

add_method String "to_debug_string" (lambda "this" {
    var result = "";

    # not very efficient, but that's not a problem because this method is just for debugging anyway
    for { var i=0; } { (not (i `equals` this.length)) } { i = (i.plus 1); } {
        var character = (this.get i);

        # FIXME: need elif or switch/case or something
        if (character `equals` "\n") {
            result = (result.concat "\\n");
        } else: {
            if (character `equals` "\t") {
                result = (result.concat "\\t");
            } else: {
                if (character `equals` "\\") {
                    result = (result.concat "\\\\");
                } else: {
                    if (character `equals` "\"") {
                        result = (result.concat "\\\"");
                    } else: {
                        result = (result.concat character);
                    };
                };
            };
        };
    };

    return (("\"".concat result).concat "\"");
});


# scope magic: variables created inside this thing are not visible outside it
{
    # get the StackFrame class
    var StackFrame = null;
    catch {
        throw (new MathError "1 + 2 is not 3");
    } [MathError "e"] {
        StackFrame = (get_class (e.stack.get 0));
    };
    if (StackFrame `equals` null) {
        throw (new AssertError "throw and catch don't seem to work");
    };

    add_method StackFrame "to_string" (lambda "this" {
        return ((("file ".concat this.filename).concat ", line ").concat (this.lineno.to_string));
    });

    add_method StackFrame "to_debug_string" (lambda "this" {
        return (("<StackFrame: ".concat (this.to_string)).concat ">");
    });
}.run (new Scope {}.definition_scope);


add_method Error "print_stack" (lambda "this" {
    # TODO: use stderr instead of stdout
    catch {
        print (((get_class this).name.concat ": ").concat this.message);

        if (not (this.stack `same_object` null)) {
            var prefix = "in";
            for { var stack_copy = (this.stack.slice 0); } { (not (stack_copy.length `equals` 0)) } {} {
                var frame = (stack_copy.pop);
                print ((("  ".concat prefix).concat " ").concat (frame.to_string));
                # TODO: print the source line

                if (prefix `equals` "in") {
                    prefix = "by";
                };
            };
        };
    } Error {    # avoid recursion!
        print "got another error while printing the stack trace of an error";
    };
});


var func = (lambda "funcname_and_argnames block" {
    var splitted = (funcname_and_argnames.split_by_whitespace);
    if (splitted.length `equals` 0) {
        throw (new ValueError "func's string argument must not be empty");
    };

    # a stupid way to join strings by spaces
    # initial i=1 skips the function name
    var argnames = "";
    for { var i = 1; } { ((i `equals` splitted.length) `same_object` false) } { i = (i.plus 1); } {
        argnames = (argnames.concat (splitted.get i));
        argnames = (argnames.concat " ");
    };

    var result = (lambda argnames block);
    result.name = (splitted.get 0);
    block.definition_scope.local_vars.set result.name result;
});
func.name = "func";

func "while condition body" {
    for {} condition {} body;
};

func "debug x" {
    print (x.to_debug_string);
};

func "not x" {
    # 'if x' throws an error if x is not a boolean
    if x {
        return false;
    };
    return true;
};

func "and x y" {
    if x {
        if y {
            return true;
        };
    } else: {
        # no matter what x is, an error must be thrown if y is not a Bool
        # this checks it :D
        not y;
    };

    return false;
};

func "or x y" {
    return (not ((not x) `and` (not y)));
};

func "assert condition" {
    if (not condition) {
        throw (new AssertError "assertion failed");
    };
};

# example:
#
#    foreach "x" [1 2 3] {
#        print (x.to_string);
#    };
func "foreach varname array block" {
    var scope = (new Scope block.definition_scope);
    for { var i = 0; } { (not (i `equals` array.length)) } { i = (i.plus 1); }
    {
        scope.local_vars.set varname (array.get i);
        block.run scope;
    };
};


{
    # gets and deletes a variable from built-in scope
    var get_and_hide_builtin = {}.definition_scope.parent_scope.local_vars.get_and_delete;

    # objects have an attrdata mapping that attributes can store their values in
    # it's not useful anywhere else because one can just create attributes using this code
    # so we hide it from the rest of the world here
    var get_attrdata = (get_and_hide_builtin "get_attrdata");
    var add_method = (get_and_hide_builtin "add_method");

    func "class class_name initializer_block inherits:" {
        if (inherits `same_object` null) {
            inherits = Object;
        };

        var klass = (new (get_class String) class_name inherits);

        func "attrib name" {
            # just to make debugging easier
            if (not (name `is_instance_of` String)) {
                throw (new TypeError ("expected a string, got ".concat (name.to_debug_string)));
            };

            var getter = (lambda "this" {
                # TODO: throw an error with a descriptive message if the name is missing
                var attrdata = (get_attrdata this);
                return (attrdata.get name);
            });
            var setter = (lambda "this value" {
                var attrdata = (get_attrdata this);
                attrdata.set name value;
            });

            getter.name = ("getter of ".concat name);
            setter.name = ("setter of ".concat name);
            klass.getters.set name getter;
            klass.setters.set name setter;
        };

        func "method methname_and_argnames block" {
            # see func for details, some of this is copied from there
            var splitted = (methname_and_argnames.split_by_whitespace);
            if (splitted.length `equals` 0) {
                throw (new ValueError "method's string argument must not be empty");
            };

            # i=1 skips the method name
            var this_and_args = "this";
            for { var i = 1; } { (not (i `equals` splitted.length)) } { i = (i.plus 1); } {
                this_and_args = (this_and_args.concat " ");
                this_and_args = (this_and_args.concat (splitted.get i));
            };

            add_method klass (splitted.get 0) (lambda this_and_args block);
        };

        var init_scope = (new Scope initializer_block.definition_scope);
        init_scope.local_vars.set "attrib" attrib;
        init_scope.local_vars.set "method" method;
        initializer_block.run init_scope;

        initializer_block.definition_scope.local_vars.set class_name klass;
    };

    # export class to the built-in namespace, but keep get_attrdata here
    {}.definition_scope.parent_scope.local_vars.set "class" class;
}.run (new Scope {}.definition_scope);
