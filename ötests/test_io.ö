var test = (import "utils").test;
var throws = (import "utils").throws;

var io = (import "<std>/io");


test "ByteArrayFileLike" {
    var f = (new io.ByteArrayFileLike);
    assert ((f.get_pos) == 0);
    assert ((f.read_all) == (new ByteArray []));
    assert (f.bytearray == (new ByteArray []));

    f.write (new ByteArray [1 2 3 4]);
    assert ((f.get_pos) == 4);
    assert ((f.read_all) == (new ByteArray []));
    assert ((f.get_pos) == 4);
    assert (f.bytearray == (new ByteArray [1 2 3 4]));

    f.set_pos (0-1);
    assert ((f.get_pos) == 0);
    assert (f.bytearray == (new ByteArray [1 2 3 4]));

    assert ((f.read_chunk 3) == (new ByteArray [1 2 3]));
    assert ((f.get_pos) == 3);
    assert ((f.read_all) == (new ByteArray [4]));
    assert ((f.get_pos) == 4);

    assert (not f.closed);
    f.close;
    assert f.closed;
    throws ValueError { var _ = (f.read_chunk 0); };
    throws ValueError { var _ = (f.read_all); };
    throws ValueError { f.write (new ByteArray []); };
    throws ValueError { f.set_pos 123; };
    throws ValueError { var _ = (f.get_pos); };
    throws ValueError { f.close; };
    throws ValueError { f.as "g" { }; };

    # initial_value should end up in the file-like, and seek position should be 0 initially
    (new io.ByteArrayFileLike initial_value:(new ByteArray [1 2 3])).as "f" {
        assert ((f.read_all) == (new ByteArray [1 2 3]));
    };
};

test "as" {
    var f = (new io.ByteArrayFileLike);
    assert (not f.closed);

    var ran = false;
    f.as "g" {
        assert (f `same_object` g);
        assert (not f.closed);
        ran = true;
    };
    assert ran;
    assert f.closed;

    f = (new io.ByteArrayFileLike);
    assert (not f.closed);

    throws MathError {
        f.as "g" {
            throw (new MathError "oh no");
        };
    };
    assert f.closed;

    var scope = none;
    (new io.ByteArrayFileLike).as "g" {
        scope = {}.definition_scope;
    };
    assert (not (scope `same_object` {}.definition_scope));
    assert ((scope.parent_scope.get_value) `same_object` {}.definition_scope);
    throws VariableError {
        var _ = g;
    };
};

test "StringWrapper" {
    var f = (new io.ByteArrayFileLike);

    var ran = false;
    (new io.StringWrapper f).as "w" {
        assert (w.encoding == "utf-8");
        assert (w.wrapped `same_object` f);
        assert (not f.closed);
        assert (not w.closed);

        w.write "hellö";
        assert ((w.wrapped.get_pos) == 6);   # utf8: hell is 4 bytes, ö is 2 bytes
        w.wrapped.set_pos 0;
        assert ((w.read_all) == "hellö");

        w.wrapped.set_pos 5;    # to the middle of ö
        throws ValueError {
            var _ = (w.read_all);
        };
        assert ((w.wrapped.get_pos) == 6);
    };
    assert f.closed;

    f = (new io.ByteArrayFileLike);
    var wrapper = none;
    throws MathError {
        (new io.StringWrapper f).as "w" {
            assert (not w.closed);
            wrapper = w;
            throw (new MathError "oh no");
        };
    };
    assert f.closed;
    assert wrapper.closed;

    var wrapper = (new io.StringWrapper (new io.ByteArrayFileLike));
    assert (not wrapper.closed);
    assert (not wrapper.wrapped.closed);
    wrapper.close;
    assert wrapper.closed;
    assert wrapper.wrapped.closed;

    throws ValueError { var _ = (wrapper.read_all); };
    throws ValueError { wrapper.write "asd"; };
    throws ValueError { wrapper.close; };
    throws ValueError { wrapper.flush; };

    var ran = false;
    throws ValueError { wrapper.as "x" { ran = true; }; };
    assert (not ran);

    (new io.StringWrapper (new io.ByteArrayFileLike)).as "wrapper" {
        throws AttribError { wrapper.set_pos 123; };
        throws AttribError { var _ = (wrapper.get_pos); };
    };
};
