var Class = (get_class String);

# can't wait until the class builtin exists, bools are needed for creating that
var Bool = (new Class "Bool" Object);
var true = (new Bool);
var false = (new Bool);

# errors are defined as early as possible because rest of the code may throw them
var ArgError = (new Class "ArgError" Error);
var AssertError = (new Class "AssertError" Error);
var AttribError = (new Class "AttribError" Error);
var KeyError = (new Class "KeyError" Error);
var MathError = (new Class "MathError" Error);
var TypeError = (new Class "TypeError" Error);
var ValueError = (new Class "ValueError" Error);
var VariableError = (new Class "VariableError" Error);

{}.definition_scope.local_vars.delete "Class";


# closure tricks: blah_getters are not visible outside this scope
{
    var setup_getter = (lambda "this" {
        return = (lambda "" {
            throw (new TypeError "cannot create new Bool objects, use true and false instead");
        });
        return.name = "setup method";
    });
    setup_getter.name = "getter of setup";
    Bool.getters.set "setup" setup_getter;

    var strings = (new Mapping [[true "true"] [false "false"]]);
    var to_debug_string_getter = (lambda "this" {
        return = (lambda "" {
            return = (strings.get this);
        });
        return.name = "to_debug_string method";
    });
    to_debug_string_getter.name = "getter of to_debug_string";
    Bool.getters.set "to_debug_string" to_debug_string_getter;

    var get_with_fallback_getter = (lambda "this" {
        return = (lambda "key fallback" {
            catch {
                return = (this.get key);
            } KeyError {
                return = fallback;
            };
        });
        return.name = "get_with_fallback method";
    });
    get_with_fallback_getter.name = "getter of get_with_fallback";
    Mapping.getters.set "get_with_fallback" get_with_fallback_getter;

}.run (new Scope {}.definition_scope);


var while = (lambda "condition_block body_block" {
    var scope = (new Scope body_block.definition_scope);
    scope.local_vars.set "keep_going" null;

    var one_iteration = {
        condition_block.run scope;
        if (scope.local_vars.get "keep_going") {
            body_block.run scope;
            one_iteration.run one_iteration.definition_scope;   # recurses :(((
        };
    };

    one_iteration.run one_iteration.definition_scope;
});
while.name = "while";

var func = (lambda "funcname_and_argnames block" {
    var splitted = (funcname_and_argnames.split_by_whitespace);
    if (splitted.length `equals` 0) {
        throw (new ValueError "func's string argument must not be empty");
    };

    # a stupid way to join strings by spaces
    var argnames = "";
    var i = 1;    # skip the function name
    while { keep_going = ((i `equals` splitted.length) `same_object` false); } {
        argnames = (argnames.concat (splitted.get i));
        argnames = (argnames.concat " ");
        i = (i.plus 1);
    };

    var result = (lambda argnames block);
    result.name = (splitted.get 0);
    block.definition_scope.local_vars.set result.name result;
});
func.name = "func";

func "debug x" {
    print (x.to_debug_string);
};

func "not x" {
    # 'if x' throws an error if x is not a boolean
    return = true;
    if x {
        return = false;
    };
};

func "assert condition" {
    if (not condition) {
        throw (new AssertError "assertion failed");
    };
};

# example:
#
#    foreach "x" [1 2 3] {
#        print (x.to_string);
#    };
func "foreach varname array block" {
    var i = 0;
    var scope = (new Scope block.definition_scope);

    while { keep_going = (not (i `equals` array.length)); } {
        scope.local_vars.set varname (array.get i);
        block.run scope;
        i = (i.plus 1);
    };
};


{
    # objects have an attrdata mapping that attributes can store their values in
    # it's not useful anywhere else because one can just create attributes using this code
    # so we hide it from the rest of the world here
    var get_attrdata = ({}.definition_scope.parent_scope.local_vars.get_and_delete "get_attrdata");

    func "class class_name initializer_block inherits: inheritable:" {
        if (inherits `same_object` null) {
            inherits = Object;
        };
        if (inheritable `same_object` null) {
            inheritable = false;
        };

        var klass = (new (get_class String) class_name inherits inheritable:inheritable);

        func "attrib name" {
            # just to make debugging easier
            if (not (name `is_instance_of` String)) {
                throw (new TypeError ("expected a string, got ".concat (name.to_debug_string)));
            };

            var getter = (lambda "this" {
                # TODO: throw an error with a descriptive message if the name is missing
                var attrdata = (get_attrdata this);
                return = (attrdata.get name);
            });
            var setter = (lambda "this value" {
                var attrdata = (get_attrdata this);
                attrdata.set name value;
            });

            getter.name = ("getter of ".concat name);
            setter.name = ("setter of ".concat name);
            klass.getters.set name getter;
            klass.setters.set name setter;
        };

        func "method methname_and_argnames block" {
            # see func for details, some of this is copied from there
            var splitted = (methname_and_argnames.split_by_whitespace);
            if (splitted.length `equals` 0) {
                throw (new ValueError "method's string argument must not be empty");
            };

            var argnames = "this ";
            var i = 1;    # skip the method name
            while { keep_going = ((i `equals` splitted.length) `same_object` false); } {
                argnames = (argnames.concat (splitted.get i));
                argnames = (argnames.concat " ");
                i = (i.plus 1);
            };

            var method_name = ((splitted.get 0).concat " method");
            var function = (lambda argnames block);
            var getter = (lambda "this" {
                return = (function.partial this);
                return.name = method_name;
            });
            getter.name = ("getter of ".concat (splitted.get 0));
            klass.getters.set (splitted.get 0) getter;
        };

        var init_scope = (new Scope initializer_block.definition_scope);
        init_scope.local_vars.set "attrib" attrib;
        init_scope.local_vars.set "method" method;
        initializer_block.run init_scope;

        initializer_block.definition_scope.local_vars.set class_name klass;
    };

    # export class to the built-in namespace, but keep get_attrdata here
    {}.definition_scope.parent_scope.local_vars.set "class" class;
}.run (new Scope {}.definition_scope);


# TODO: add these methods to StackFrame
#
#    method "to_string" {
#        return = ((("file ".concat this.filename).concat ", line ").concat (this.lineno.to_string));
#    };
#
#    method "to_debug_string" {
#        return = (("<StackFrame: ".concat (this.to_string)).concat ">");
#    };
