# FIXME: these suck
var true = "true";
var false = "false";

# closure tricks: if_mapping is visible only for the if function
var if = null;
{
    # this thing maps if conditions to blocks that are ran on the condition
    var if_mapping = (new Mapping [
        [true { block.run (new Scope block.definition_scope); }]
        [false {}]
    ]);

    if = (lambda "condition block" {
        (if_mapping.get condition).run {}.definition_scope;
    });
}.run (new Scope {}.definition_scope);
if.name = "if";        # func will set these automatically

var while = (lambda "condition_block body_block" {
    var scope = (new Scope body_block.definition_scope);
    scope.local_vars.set "keep_going" null;

    var one_iteration = {
        condition_block.run scope;
        if (scope.local_vars.get "keep_going") {
            body_block.run scope;
            one_iteration.run one_iteration.definition_scope;   # recurses :(((
        };
    };

    one_iteration.run one_iteration.definition_scope;
});
while.name = "while";

var func = (lambda "funcname_and_argnames block" {
    var splitted = (funcname_and_argnames.split_by_whitespace);
    if (splitted.length `equals` 0) {
        throw "func's string argument must not be empty";
    };

    # a stupid way to join strings by spaces
    var argnames = "";
    var i = 1;    # skip the function name
    while { keep_going = ((i `equals` splitted.length) `same_object` false); } {
        argnames = (argnames.concat (splitted.get i));
        argnames = (argnames.concat " ");
        i = (i.plus 1);
    };

    var result = (lambda argnames block);
    result.name = (splitted.get 0);
    block.definition_scope.local_vars.set result.name result;
});
func.name = "func";

func "debug x" {
    print (x.to_debug_string);
};

func "not x" {
    # 'if x' throws an error if x is not a boolean
    return = true;
    if x {
        return = false;
    };
};

func "assert condition" {
    if (not condition) {
        throw "assertion failed";
    };
};

# example:
#
#    foreach "x" [1 2 3] {
#        print (x.to_string);
#    };
func "foreach varname array block" {
    var i = 0;
    var scope = (new Scope block.definition_scope);

    while { keep_going = (not (i `equals` array.length)); } {
        scope.local_vars.set varname (array.get i);
        block.run scope;
        i = (i.plus 1);
    };
};


func "class name initializer_block" {
    var klass = (new (get_class String) name Object);

    func "add_method name function" {
        var getter = (lambda "this" {
            return = (function.partial this);
            return.name = (name.concat " method");
        });
        getter.name = ("getter of ".concat name);
        klass.getters.set name getter;
    };

    func "method methname_and_argnames block" {
        # see func for details, some of this is copied from there
        var splitted = (methname_and_argnames.split_by_whitespace);
        if (splitted.length `equals` 0) {
            throw "method's string argument must not be empty";
        };

        var argnames = "this ";
        var i = 1;    # skip the method name
        while { keep_going = ((i `equals` splitted.length) `same_object` false); } {
            argnames = (argnames.concat (splitted.get i));
            argnames = (argnames.concat " ");
            i = (i.plus 1);
        };
        add_method (splitted.get 0) (lambda argnames block);
    };

    var init_scope = (new Scope initializer_block.definition_scope);
    init_scope.local_vars.set "method" method;
    initializer_block.run init_scope;

    initializer_block.definition_scope.local_vars.set name klass;
};
