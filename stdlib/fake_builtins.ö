# logic stuff
var not = (array_func {
    if ((arguments::get_length)::equals 1) {
        if (arguments::get 0) { return false; };
        return true;
    };
    error "'not' should be called with exactly 1 argument";
});

var and = (array_func {
    arguments::foreach "arg" {
        if (not arg) { return false; };
    };
    return true;
});

var or = (array_func {
    arguments::foreach "arg" {
        if arg { return true; };
    };
});

var assert = (array_func {
    var msg = null;
    if ((arguments::get_length)::equals 1) {
        msg = "assertion failed";
    };
    if ((arguments::get_length)::equals 2) {
        msg = (arguments::get 1);
    };
    if (msg::equals null) {
        error "should be 'assert CONDITION;' or 'assert CONDITION MESSAGE;'";
    };

    if (not (arguments::get 0)) {
        error msg;
    };
});


# control flow stuff
var while = (array_func {
    # this is an array_func because zip needs this and func needs zip
    assert ((arguments::get_length)::equals 2)
           "should be 'while { CONDITION } { ... };'";

    var condition = (arguments::get 0);
    var body = (arguments::get 1);

    var context = (body.definition_context::create_subcontext);
    var run_stuff = {
        if (condition::run_with_return context) {
            body::run context;

            # FIXME: this recursing is no good :/( infinite loops don't work
            run_stuff::run;
        };
    };
    run_stuff::run;
});

var func = (array_func {
    # this uses zip, defined below
    assert (not ((arguments::get_length)::equals 0))
           "should be 'func ARGUMENT_STRINGS { ... }'";
    var argument_names = (arguments::slice 0 -1);
    var body = (arguments::get -1);

    return (array_func {
        var context = (body.definition_context::create_subcontext);

        # set arguments as local variables
        # now the arguments variable is local to this inner array_func (lol)
        (zip argument_names arguments)::foreach "pair" {
            context.local_vars::set (pair::get 0) (pair::get 1);
        };
        return (body::run_with_return context);
    });
});


# misc utils
var zip = (array_func {
    # this is an array_func because func uses this
    # currenty this relies on (arguments::get 0)
    if ((arguments::get_length)::equals 0) {
        return [];
    };

    var result = [];
    var length = ((arguments::get 0)::get_length);

    # TODO: make sure the arrays are of a consistent length

    while { (not ((result::get_length)::equals length)) } {
        var index = (result::get_length);    # 0, 1, 2, ...
        var result_item = [];
        arguments::foreach "zipped_array" {
            result_item::add (zipped_array::get index);
        };
        result::add result_item;
    };
    return result;
});

var partial = (array_func {
    var func = (arguments::get 0);
    var partial_args = (arguments::slice 1);

    return (array_func {
        # here arguments means the arguments passed to the partialled function
        var the_args = (partial_args::copy);
        arguments::foreach "arg" { the_args::add arg; };
        return (call func the_args);
    });
});


# oop
var is_instance_of = (func "object" "klass" {
    var looking4 = (get_class object);
    while { (and (not (same_object klass null)) (not result)) } {
        if (same_object klass looking4) {
            return true;
        };
        klass = klass.baseclass;
    };
    return false;
});

var inheriting = (new Object);    # special marker
var class = (array_func {
    var errormsg = "should be 'class { ... };' or 'class inheriting SomeBaseClass { ... };'";
    assert ([1 3]::contains (arguments::get_length)) errormsg;

    var baseclass;
    if ((arguments::get_length)::equals 3) {
        assert (same_object (arguments::get 0) inheriting)
               "should be 'class inheriting SomeBaseClass { ... };'";
        baseclass = (arguments::get 1);
    };
    if ((arguments::get_length)::equals 1) {
        baseclass = Object;
    };
    var body = (arguments::get -1);

    var context = ({ }.definition_context.parent_context::create_subcontext);
    body::run context;
    return (new (get_class String) baseclass context.local_vars);
});

var meth = (partial func "this");
